<<<<<<< HEAD
dXdkz<-mARS0$coefficients["C:z"] ; if(is.na(dXdkz)){dXdkz<-0}
Zt0<-mean(females$z[which(females$t==1)])
kt0<-mean(females$C[which(females$t==1)])
Zt1<-mean(females$z[which(females$t==2)])
kt1<-mean(females$C[which(females$t==2)])
Xtt<-mean(log(females$ARS[which(females$t==1)]))
Xtt
XTT<-mean(log(females$ARS[which(females$t==2)]))
XTT
XtT<-intercept+Zt0*dXdz+kt1*dXdk
XtT
intercept+Zt1*dXdz+kt1*dXdk
Zkt1<-mean(females$C[which(females$t==1)]*females$z[which(females$t==1)])
Zkt1
Zt1kt2<-mean(females$z[which(females$t==1)]*females$C[which(females$t==2)])
mARS0<-glm(ARS~1+C+z,data=females[which(females$t==1 | females$t==2),],family=poisson)
summary(mARS0)
intercept<-mARS0$coefficients[1]
dXdz<-mARS0$coefficients["z"]
dXdk<-mARS0$coefficients["C"]
dXdkz<-mARS0$coefficients["C:z"] ; if(is.na(dXdkz)){dXdkz<-0}
dXdkz
Zt0<-mean(females$z[which(females$t==1)])
kt0<-mean(females$C[which(females$t==1)])
Zt1<-mean(females$z[which(females$t==2)])
kt1<-mean(females$C[which(females$t==2)])
Xtt<-mean(log(females$ARS[which(females$t==1)]))
XTT<-mean(log(females$ARS[which(females$t==2)]))
XtT<-intercept+Zt0*dXdz+kt1*dXdk
XtT
Xtt
intercept+Zt1*dXdz+kt1*dXdk
XTT
intercept+Zt2*dXdz+kt2*dXdk
intercept+Zt0*dXdz+kt0*dXdk
XTt<-intercept+Zt1*dXdz+kt0*dXdk
XTt
Xtt<-mean(log(females$ARS[which(females$t==1)]))
Xtt
intercept+Zt1*dXdz+kt1*dXdk
AX<-as.data.frame(matrix(data=c(Xtt,XTt,XtT,XTT,0,1,0,1,0,0,1,1),ncol=3))
m1X<-(lm(V1~V2*V3,data=AX))
m1X
0.5*(XTT-XtT + XTt-Xtt)
0.5*(XTT-XTt + XtT-Xtt)
m1X<-(lm(V1~V2+V3,data=AX))
0.5*(XTT-XtT + XTt-Xtt)
0.5*(XTT-XTt + XtT-Xtt)
max(females$t)
evol<-vector(length=max(females$t)-1)
evol
ecol<-vector(length=max(females$t)-1)
evol<-vector(length=max(females$t)-1)
ecol<-vector(length=max(females$t)-1)
for (tempus in 2:max(females$t))
{
mARS0<-glm(ARS~1+C+z,data=females[which(females$t==(tempus-1) | females$t==tempus),],family=poisson)
intercept<-mARS0$coefficients[1]
dXdz<-mARS0$coefficients["z"]
dXdk<-mARS0$coefficients["C"]
Zt0<-mean(females$z[which(females$t==(tempus-1))])
kt0<-mean(females$C[which(females$t==(tempus-1))])
Zt1<-mean(females$z[which(females$t==tempus)])
kt1<-mean(females$C[which(females$t==tempus)])
Xtt<-mean(log(females$ARS[which(females$t==(tempus-1))])) # not exactly intercept+Zt0*dXdz+kt0*dXdk because impossible to account for the interaction (??)
XTT<-mean(log(females$ARS[which(females$t==tempus)]))# not exactly intercept+Zt1*dXdz+kt1*dXdk because impossible to account for the interaction (??)
XtT<-intercept+Zt0*dXdz+kt1*dXdk
XTt<-intercept+Zt1*dXdz+kt0*dXdk
AX<-as.data.frame(matrix(data=c(Xtt,XTt,XtT,XTT,0,1,0,1,0,0,1,1),ncol=3))
m1X<-(lm(V1~V2+V3,data=AX))
evol[tempus-1]<-0.5*(XTT-XtT + XTt-Xtt)
ecol[tempus-1]<-0.5*(XTT-XTt + XtT-Xtt)
}
tempus
evol
ecol
mARS0<-glm(ARS~1+C+z,data=females[which(females$t==(tempus-1) | females$t==tempus),],family=poisson)
mARS0
intercept<-mARS0$coefficients[1]
dXdz<-mARS0$coefficients["z"]
dXdk<-mARS0$coefficients["C"]
Zt0<-mean(females$z[which(females$t==(tempus-1))])
kt0<-mean(females$C[which(females$t==(tempus-1))])
Zt1<-mean(females$z[which(females$t==tempus)])
kt1<-mean(females$C[which(females$t==tempus)])
Xtt<-mean(log(females$ARS[which(females$t==(tempus-1))])) # not exactly intercept+Zt0*dXdz+kt0*dXdk because impossible to account for the interaction (??)
XTT<-mean(log(females$ARS[which(females$t==tempus)]))# not exactly intercept+Zt1*dXdz+kt1*dXdk because impossible to account for the interaction (??)
XtT<-intercept+Zt0*dXdz+kt1*dXdk
XTt<-intercept+Zt1*dXdz+kt0*dXdk
AX<-as.data.frame(matrix(data=c(Xtt,XTt,XtT,XTT,0,1,0,1,0,0,1,1),ncol=3))
m1X<-(lm(V1~V2+V3,data=AX))
AX
XTT<-mean(log(females$ARS[which(females$t==tempus)]))# not exactly intercept+Zt1*dXdz+kt1*dXdk because impossible to account for the interaction (??)
XTT
females$ARS[which(females$t==tempus)]
log(females$ARS[which(females$t==tempus)])
plot(density(exp(females$ARS)))#very grossly gaussian distribution
intercept+Zt0*dXdz+kt0*dXdk
Xtt<-mean(log(females$ARS[which(females$t==(tempus-1))])) # not exactly intercept+Zt0*dXdz+kt0*dXdk because impossible to account for the interaction (??)
Xtt
log(mean(females$ARS[which(females$t==(tempus-1))]))
(mean(females$ARS[which(females$t==(tempus-1))]))
exp(intercept+Zt0*dXdz+kt0*dXdk)
exp(intercept+Zt0*females$z[which(females$t==(tempus-1))]+kt1*females$z[which(females$t==(tempus-1))])
exp(intercept+Zt0*females$z[which(females$t==(tempus-1))]+kt1*females$C[which(females$t==(tempus-1))])
females$z[which(females$t==(tempus-1))]
Zt0*females$z[which(females$t==(tempus-1))]
kt1
females$C[which(females$t==(tempus-1))]
intercept
intercept+Zt0*females$z[which(females$t==(tempus-1))]+kt1*females$C[which(females$t==(tempus-1))]
intercept+Zt0*dXdz+kt1*dXdk
dXdk
exp(intercept+females$z[which(females$t==(tempus-1))]*dXdz+females$C[which(females$t==(tempus-1))]*dXdk)
mean(exp(intercept+females$z[which(females$t==(tempus-1))]*dXdz+females$C[which(females$t==(tempus-1))]*dXdk))
Xtt
Xtt<-mean(females$ARS[which(females$t==(tempus-1))]) # not exactly exp(intercept+Zt0*dXdz+kt0*dXdk) I do not want to account for the interaction (??) as it is problematic for XtT and XTt
Xtt
evol<-vector(length=max(females$t)-1)
ecol<-vector(length=max(females$t)-1)
for (tempus in 2:max(females$t))
{
mARS0<-glm(ARS~1+C+z,data=females[which(females$t==(tempus-1) | females$t==tempus),],family=poisson)
intercept<-mARS0$coefficients[1]
dXdz<-mARS0$coefficients["z"]
dXdk<-mARS0$coefficients["C"]
Zt0<-mean(females$z[which(females$t==(tempus-1))])
kt0<-mean(females$C[which(females$t==(tempus-1))])
Zt1<-mean(females$z[which(females$t==tempus)])
kt1<-mean(females$C[which(females$t==tempus)])
Xtt<-mean(females$ARS[which(females$t==(tempus-1))]) # not exactly exp(intercept+Zt0*dXdz+kt0*dXdk) I do not want to account for the interaction (??) as it is problematic for XtT and XTt
XTT<-mean(females$ARS[which(females$t==tempus)])# not exactly exp(intercept+Zt1*dXdz+kt1*dXdk) I do not want to account for the interaction (??) as it is problematic for XtT and XTt
XtT<-exp(intercept+Zt0*dXdz+kt1*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
XTt<-exp(intercept+Zt1*dXdz+kt0*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
AX<-as.data.frame(matrix(data=c(Xtt,XTt,XtT,XTT,0,1,0,1,0,0,1,1),ncol=3))
m1X<-(lm(V1~V2+V3,data=AX))
evol[tempus-1]<-0.5*(XTT-XtT + XTt-Xtt)
ecol[tempus-1]<-0.5*(XTT-XTt + XtT-Xtt)
}
plot(evol)
plot(ecol)
plot(evol/(ecol+evol)
)
ecol+evol
evol
plot(abs(evol)/(abs(ecol)+abs(evol)))
plot(evol)
plot(ecol)
(abs(evol)/(abs(ecol)+abs(evol)))
mean(abs(evol)/(abs(ecol)+abs(evol)))
mean(abs(evol)/(abs(ecol)))
plot(females$ARS)
tapply(X=females$ARS,INDEX=females$t,FUN=mean)
females$ARS
plot(tapply(X=females$ARS,INDEX=females$t,FUN=mean))
plot(Camemberts,popSize)
popsize<-table(popfile$t)
popsize
plot(log(tapply(X=females$ARS,INDEX=females$t,FUN=mean)))
points(evol,type="l",col="red")
evol
plot(log(tapply(X=females$ARS,INDEX=females$t,FUN=mean)),ylim=c(0,6))#log to see better what is going on at g13
points(evol,type="l",col="red")
plot(log(tapply(X=females$ARS,INDEX=females$t,FUN=mean)),ylim=c(0,6))#log to see better what is going on at g13
points(abs(evol),type="l",col="red")
points(log(abs(evol)),type="l",col="red")
plot(log(tapply(X=females$ARS,INDEX=females$t,FUN=mean)),ylim=c(0,6))#log to see better what is going on at g13
points(log(abs(evol)),type="l",col="red")
plot(log(tapply(X=females$ARS,INDEX=females$t,FUN=mean)),ylim=c(0,6))#log to see better what is going on at g13
points(abs(evol),type="l",col="red")
points(abs(ecol),type="l",col="blue")
points(evol/max(evol),type="l",col="red")
plot(log(tapply(X=females$ARS,INDEX=females$t,FUN=mean)),ylim=c(0,6))#log to see better what is going on at g13
plot(log(tapply(X=females$ARS,INDEX=females$t,FUN=mean)),ylim=c(-6,6))#log to see better what is going on at g13
points(evol/max(evol),type="l",col="red")
points(evol/sd(evol),type="l",col="red")
plot(log(tapply(X=females$ARS,INDEX=females$t,FUN=mean)),ylim=c(-6,6))#log to see better what is going on at g13
points(evol/sd(evol),type="l",col="red")
plot(log(tapply(X=females$ARS,INDEX=females$t,FUN=mean)),ylim=c(-6,6))#log to see better what is going on at g13
points(evol/sd(evol),x=2:30,type="l",col="red")
points(ecol/sd(ecol),type="l",col="blue")
plot(log(tapply(X=females$ARS,INDEX=females$t,FUN=mean)),ylim=c(-6,6))#log to see better what is going on at g13
points(evol/sd(evol),x=2:30,type="l",col="red")
points(ecol/sd(ecol),x=2:30,type="l",col="blue")
evol/ecol
points(evol/ecol,x=2:30,type="l",col="green")
plot(log(tapply(X=females$ARS,INDEX=females$t,FUN=mean)),ylim=c(-6,6))#log to see better what is going on at g13
points(evol/sd(evol),x=2:30,type="l",col="red")
points(ecol/sd(ecol),x=2:30,type="l",col="blue")
points(abs(evol)/abs(ecol),x=2:30,type="l",col="green")
plot(log(tapply(X=females$ARS,INDEX=females$t,FUN=mean)),ylim=c(-1,1))#log to see better what is going on at g13
points(evol/sd(evol),x=2:30,type="l",col="red")
points(ecol/sd(ecol),x=2:30,type="l",col="blue")
points(abs(evol)/abs(ecol),x=2:30,type="l",col="green")
plot(log(tapply(X=females$ARS,INDEX=females$t,FUN=mean)),ylim=c(-6,6))#log to see better what is going on at g13
points(evol/sd(evol),x=2:30,type="l",col="red")
points(ecol/sd(ecol),x=2:30,type="l",col="blue")
points(abs(evol)/abs(ecol),x=2:30,type="l",col="green")
mean(abs(evol)/abs(ecol))
plot(log(tapply(X=females$ARS,INDEX=females$t,FUN=mean)),ylim=c(-5,6))#log to see better what is going on at g13
points(evol/sd(evol),x=2:30,type="l",col="red")
points(ecol/sd(ecol),x=2:30,type="l",col="blue")
points(abs(evol)/abs(ecol),x=2:30,type="l",col="green")
plot(log(tapply(X=females$ARS,INDEX=females$t,FUN=mean)),ylim=c(-5,6),type="b")#log to see better what is going on at g13
points(evol/sd(evol),x=2:30,type="l",col="red")
points(ecol/sd(ecol),x=2:30,type="l",col="blue")
points(abs(evol)/abs(ecol),x=2:30,type="l",col="green")
legend(x="bottomright",legend=c("Noff","Evol","Ecol"),col=c("black","red","blue"),type=c("b","l","l"))
legend(x="bottomright",legend=c("Noff","Evol","Ecol"),col=c("black","red","blue"))
mean(abs(evol)/abs(ecol))
legend(x="bottomright",legend=c("Noff","Evol","Ecol"),col=c("black","red","blue"),lwd=2)
legend(x="bottomright",legend=c("Noff","Evol","Ecol","Abs(evol/ecol)"),col=c("black","red","blue","green"),lwd=2)
plot(log(tapply(X=females$ARS,INDEX=females$t,FUN=mean)),ylim=c(-5,6),type="b")#log to see better what is going on at g13
points(evol/sd(evol),x=2:30-0.5,type="l",col="red")
points(ecol/sd(ecol),x=2:30-0.5,type="l",col="blue")
points(abs(evol)/abs(ecol),x=2:30,type="l",col="green")
points(abs(evol)/abs(ecol),x=2:30-0.5,type="l",col="green")
plot(log(tapply(X=females$ARS,INDEX=females$t,FUN=mean)),ylim=c(-5,6),type="b")#log to see better what is going on at g13
points(evol/sd(evol),x=2:30-0.5,type="l",col="red")
points(ecol/sd(ecol),x=2:30-0.5,type="l",col="blue")
points(abs(evol)/abs(ecol),x=2:30-0.5,type="l",col="green")
legend(x="bottomright",legend=c("Noff","Evol","Ecol","Abs(evol/ecol)"),col=c("black","red","blue","green"),lwd=2)
mARS1<-glm(ARS~1+C+z+bvs,data=females[which(females$t==(tempus-1) | females$t==tempus),],family=poisson)
mARS1
summary(mARS1)
gt1<-mean(females$bvs[which(females$t==tempus)])
gt1
gt0<-mean(females$bvs[which(females$t==(tempus-1))])
gt0
mARS1<-glm(ARS~1+C+z+bvs,data=females[which(females$t==(tempus-1) | females$t==tempus),],family=poisson)
intercept<-mARS0$coefficients[1]
dXdz<-mARS1$coefficients["z"]
dXdk<-mARS1$coefficients["C"]
dXdg<-mARS1$coefficients["bvs"]
Zt0<-mean(females$z[which(females$t==(tempus-1))])
kt0<-mean(females$C[which(females$t==(tempus-1))])
gt0<-mean(females$bvs[which(females$t==(tempus-1))])
Zt1<-mean(females$z[which(females$t==tempus)])
kt1<-mean(females$C[which(females$t==tempus)])
gt1<-mean(females$bvs[which(females$t==tempus)])
Xttt<-mean(females$ARS[which(females$t==(tempus-1))]) # not exactly exp(intercept+Zt0*dXdz+kt0*dXdk) I do not want to account for the interaction (??) as it is problematic for XtT and XTt
XTTT<-mean(females$ARS[which(females$t==tempus)])# not exactly exp(intercept+Zt1*dXdz+kt1*dXdk) I do not want to account for the interaction (??) as it is problematic for XtT and XTt
XttT<-exp(intercept+Zt0*dXdz+gt0*dXdg+kt1*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
XtTt<-exp(intercept+Zt0*dXdz+gt1*dXdg+kt0*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
XtTT<-exp(intercept+Zt0*dXdz+gt1*dXdg+kt1*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
XTtt<-exp(intercept+Zt1*dXdz+gt0*dXdg+kt0*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
XTtT<-exp(intercept+Zt1*dXdz+gt0*dXdg+kt1*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
XTTt<-exp(intercept+Zt1*dXdz+gt1*dXdg+kt0*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
AX<-as.data.frame(matrix(data=c(Xtt,XTt,XtT,XTT,0,1,0,1,0,0,1,1),ncol=3))
AX
AX<-data.frame(c(Xttt,XttT,XtTt,XtTT,XTtt,XTtT,XTTt,XTTT),c(0,0,0,0,1,1,1,1))
AX
AX<-data.frame(c(Xttt,XttT,XtTt,XtTT,XTtt,XTtT,XTTt,XTTT),c(0,0,0,0,1,1,1,1),c(0,0,1,1,0,0,1,1),c(0,1,0,1,0,1,0,1))
AX
names(AX)
names(AX)<-c("X","Z","G","K")
AX
m1X<-(lm(X~Z+G+K,data=AX))
m1X
m1X$coefficients["G"]
evol<-vector(length=max(females$t)-1)
plas<-vector(length=max(females$t)-1)
ecol<-vector(length=max(females$t)-1)
for (tempus in 2:max(females$t))
{
mARS1<-glm(ARS~1+C+z+bvs,data=females[which(females$t==(tempus-1) | females$t==tempus),],family=poisson)
intercept<-mARS0$coefficients[1]
dXdz<-mARS1$coefficients["z"]
dXdk<-mARS1$coefficients["C"]
dXdg<-mARS1$coefficients["bvs"]
Zt0<-mean(females$z[which(females$t==(tempus-1))])
kt0<-mean(females$C[which(females$t==(tempus-1))])
gt0<-mean(females$bvs[which(females$t==(tempus-1))])
Zt1<-mean(females$z[which(females$t==tempus)])
kt1<-mean(females$C[which(females$t==tempus)])
gt1<-mean(females$bvs[which(females$t==tempus)])
Xttt<-mean(females$ARS[which(females$t==(tempus-1))]) # not exactly exp(intercept+Zt0*dXdz+kt0*dXdk) I do not want to account for the interaction (??) as it is problematic for XtT and XTt
XTTT<-mean(females$ARS[which(females$t==tempus)])# not exactly exp(intercept+Zt1*dXdz+kt1*dXdk) I do not want to account for the interaction (??) as it is problematic for XtT and XTt
XttT<-exp(intercept+Zt0*dXdz+gt0*dXdg+kt1*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
XtTt<-exp(intercept+Zt0*dXdz+gt1*dXdg+kt0*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
XtTT<-exp(intercept+Zt0*dXdz+gt1*dXdg+kt1*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
XTtt<-exp(intercept+Zt1*dXdz+gt0*dXdg+kt0*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
XTtT<-exp(intercept+Zt1*dXdz+gt0*dXdg+kt1*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
XTTt<-exp(intercept+Zt1*dXdz+gt1*dXdg+kt0*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
AX<-as.data.frame(matrix(data=c(Xttt,XttT,XtTt,XtTT,XTtt,XTtT,XTTt,XTTT,0,1,0,1,0,0,1,1),ncol=4))
AX<-data.frame(c(Xttt,XttT,XtTt,XtTT,XTtt,XTtT,XTTt,XTTT),c(0,0,0,0,1,1,1,1),c(0,0,1,1,0,0,1,1),c(0,1,0,1,0,1,0,1))
names(AX)<-c("X","Z","G","K")
m1X<-(lm(X~Z+G+K,data=AX))
evol[tempus-1]<-m1X$coefficients["G"]
plas[tempus-1]<-m1X$coefficients["Z"]
ecol[tempus-1]<-m1X$coefficients["Z"]
}
plot(log(tapply(X=females$ARS,INDEX=females$t,FUN=mean)),ylim=c(-5,6),type="b")#log to see better what is going on at g13
points(evol/sd(evol),x=2:30-0.5,type="l",col="red")
points(ecol/sd(ecol),x=2:30-0.5,type="l",col="blue")
points(plas/sd(evol),x=2:30-0.5,type="l",col="purple")
plas
evol
ecol
plot(log(tapply(X=females$ARS,INDEX=females$t,FUN=mean)),ylim=c(-0.5,0.5),type="b")#log to see better what is going on at g13
points(evol/sd(evol),x=2:30-0.5,type="l",col="red")
points(plas/sd(evol),x=2:30-0.5,type="l",col="purple")
points(ecol/sd(ecol),x=2:30-0.5,type="l",col="blue")
evol<-vector(length=max(females$t)-1)
plas<-vector(length=max(females$t)-1)
ecol<-vector(length=max(females$t)-1)
for (tempus in 2:max(females$t))
{
mARS1<-glm(ARS~1+C+I(z-bvs)+bvs,data=females[which(females$t==(tempus-1) | females$t==tempus),],family=poisson)
intercept<-mARS0$coefficients[1]
dXdz<-mARS1$coefficients["z"]
dXdk<-mARS1$coefficients["C"]
dXdg<-mARS1$coefficients["bvs"]
Zt0<-mean(females$z[which(females$t==(tempus-1))])
kt0<-mean(females$C[which(females$t==(tempus-1))])
gt0<-mean(females$bvs[which(females$t==(tempus-1))])
Zt1<-mean(females$z[which(females$t==tempus)])
kt1<-mean(females$C[which(females$t==tempus)])
gt1<-mean(females$bvs[which(females$t==tempus)])
Xttt<-mean(females$ARS[which(females$t==(tempus-1))]) # not exactly exp(intercept+Zt0*dXdz+kt0*dXdk) I do not want to account for the interaction (??) as it is problematic for XtT and XTt
XTTT<-mean(females$ARS[which(females$t==tempus)])# not exactly exp(intercept+Zt1*dXdz+kt1*dXdk) I do not want to account for the interaction (??) as it is problematic for XtT and XTt
XttT<-exp(intercept+Zt0*dXdz+gt0*dXdg+kt1*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
XtTt<-exp(intercept+Zt0*dXdz+gt1*dXdg+kt0*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
XtTT<-exp(intercept+Zt0*dXdz+gt1*dXdg+kt1*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
XTtt<-exp(intercept+Zt1*dXdz+gt0*dXdg+kt0*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
XTtT<-exp(intercept+Zt1*dXdz+gt0*dXdg+kt1*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
XTTt<-exp(intercept+Zt1*dXdz+gt1*dXdg+kt0*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
AX<-as.data.frame(matrix(data=c(Xttt,XttT,XtTt,XtTT,XTtt,XTtT,XTTt,XTTT,0,1,0,1,0,0,1,1),ncol=4))
AX<-data.frame(c(Xttt,XttT,XtTt,XtTT,XTtt,XTtT,XTTt,XTTT),c(0,0,0,0,1,1,1,1),c(0,0,1,1,0,0,1,1),c(0,1,0,1,0,1,0,1))
names(AX)<-c("X","Z","G","K")
m1X<-(lm(X~Z+G+K,data=AX))
evol[tempus-1]<-m1X$coefficients["G"]
plas[tempus-1]<-m1X$coefficients["Z"]
ecol[tempus-1]<-m1X$coefficients["Z"]
}
plot(log(tapply(X=females$ARS,INDEX=females$t,FUN=mean)),ylim=c(-0.5,0.5),type="b")#log to see better what is going on at g13
points(evol/sd(evol),x=2:30-0.5,type="l",col="red")
points(plas/sd(evol),x=2:30-0.5,type="l",col="purple")
evol
mARS1<-glm(ARS~1+C+I(z-bvs)+bvs,data=females[which(females$t==(tempus-1) | females$t==tempus),],family=poisson)
mARS1
mARS1<-glm(ARS~1+C+z+bvs,data=females[which(females$t==(tempus-1) | females$t==tempus),],family=poisson)
mARS1
evol<-vector(length=max(females$t)-1)
plas<-vector(length=max(females$t)-1)
ecol<-vector(length=max(females$t)-1)
for (tempus in 2:max(females$t))
{
mARS1<-glm(ARS~1+C+z+bvs,data=females[which(females$t==(tempus-1) | females$t==tempus),],family=poisson)
intercept<-mARS0$coefficients[1]
dXdz<-mARS1$coefficients["z"]
dXdk<-mARS1$coefficients["C"]
dXdg<-mARS1$coefficients["bvs"]
Zt0<-mean(females$z[which(females$t==(tempus-1))])
kt0<-mean(females$C[which(females$t==(tempus-1))])
gt0<-mean(females$bvs[which(females$t==(tempus-1))])
Zt1<-mean(females$z[which(females$t==tempus)])
kt1<-mean(females$C[which(females$t==tempus)])
gt1<-mean(females$bvs[which(females$t==tempus)])
Xttt<-mean(females$ARS[which(females$t==(tempus-1))]) # not exactly exp(intercept+Zt0*dXdz+kt0*dXdk) I do not want to account for the interaction (??) as it is problematic for XtT and XTt
XTTT<-mean(females$ARS[which(females$t==tempus)])# not exactly exp(intercept+Zt1*dXdz+kt1*dXdk) I do not want to account for the interaction (??) as it is problematic for XtT and XTt
XttT<-exp(intercept+Zt0*dXdz+gt0*dXdg+kt1*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
XtTt<-exp(intercept+Zt0*dXdz+gt1*dXdg+kt0*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
XtTT<-exp(intercept+Zt0*dXdz+gt1*dXdg+kt1*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
XTtt<-exp(intercept+Zt1*dXdz+gt0*dXdg+kt0*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
XTtT<-exp(intercept+Zt1*dXdz+gt0*dXdg+kt1*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
XTTt<-exp(intercept+Zt1*dXdz+gt1*dXdg+kt0*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
AX<-as.data.frame(matrix(data=c(Xttt,XttT,XtTt,XtTT,XTtt,XTtT,XTTt,XTTT,0,1,0,1,0,0,1,1),ncol=4))
AX<-data.frame(c(Xttt,XttT,XtTt,XtTT,XTtt,XTtT,XTTt,XTTT),c(0,0,0,0,1,1,1,1),c(0,0,1,1,0,0,1,1),c(0,1,0,1,0,1,0,1))
names(AX)<-c("X","Z","G","K")
m1X<-(lm(X~Z+G+K,data=AX))
evol[tempus-1]<-m1X$coefficients["G"]
plas[tempus-1]<-m1X$coefficients["Z"]
ecol[tempus-1]<-m1X$coefficients["Z"]
}
evol
plas
ecol
plot(evol)
evol<-vector(length=max(females$t)-1)
plas<-vector(length=max(females$t)-1)
ecol<-vector(length=max(females$t)-1)
#for (tempus in 2:max(females$t))
for (tempus in 2:11)
{
mARS1<-glm(ARS~1+C+z+bvs,data=females[which(females$t==(tempus-1) | females$t==tempus),],family=poisson)
intercept<-mARS0$coefficients[1]
dXdz<-mARS1$coefficients["z"]
dXdk<-mARS1$coefficients["C"]
dXdg<-mARS1$coefficients["bvs"]
Zt0<-mean(females$z[which(females$t==(tempus-1))])
kt0<-mean(females$C[which(females$t==(tempus-1))])
gt0<-mean(females$bvs[which(females$t==(tempus-1))])
Zt1<-mean(females$z[which(females$t==tempus)])
kt1<-mean(females$C[which(females$t==tempus)])
gt1<-mean(females$bvs[which(females$t==tempus)])
Xttt<-mean(females$ARS[which(females$t==(tempus-1))]) # not exactly exp(intercept+Zt0*dXdz+kt0*dXdk) I do not want to account for the interaction (??) as it is problematic for XtT and XTt
XTTT<-mean(females$ARS[which(females$t==tempus)])# not exactly exp(intercept+Zt1*dXdz+kt1*dXdk) I do not want to account for the interaction (??) as it is problematic for XtT and XTt
XttT<-exp(intercept+Zt0*dXdz+gt0*dXdg+kt1*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
XtTt<-exp(intercept+Zt0*dXdz+gt1*dXdg+kt0*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
XtTT<-exp(intercept+Zt0*dXdz+gt1*dXdg+kt1*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
XTtt<-exp(intercept+Zt1*dXdz+gt0*dXdg+kt0*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
XTtT<-exp(intercept+Zt1*dXdz+gt0*dXdg+kt1*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
XTTt<-exp(intercept+Zt1*dXdz+gt1*dXdg+kt0*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
AX<-as.data.frame(matrix(data=c(Xttt,XttT,XtTt,XtTT,XTtt,XTtT,XTTt,XTTT,0,1,0,1,0,0,1,1),ncol=4))
AX<-data.frame(c(Xttt,XttT,XtTt,XtTT,XTtt,XTtT,XTTt,XTTT),c(0,0,0,0,1,1,1,1),c(0,0,1,1,0,0,1,1),c(0,1,0,1,0,1,0,1))
names(AX)<-c("X","Z","G","K")
m1X<-(lm(X~Z+G+K,data=AX))
evol[tempus-1]<-m1X$coefficients["G"]
plas[tempus-1]<-m1X$coefficients["Z"]
ecol[tempus-1]<-m1X$coefficients["Z"]
}
plot(evol)
popfile[which(popfile$t==13),]
evol/sd(evol)
evol<-vector(length=max(females$t)-1)
plas<-vector(length=max(females$t)-1)
ecol<-vector(length=max(females$t)-1)
for (tempus in 2:max(females$t))
{
mARS1<-glm(ARS~1+C+z+bvs,data=females[which(females$t==(tempus-1) | females$t==tempus),],family=poisson)
intercept<-mARS0$coefficients[1]
dXdz<-mARS1$coefficients["z"]
dXdk<-mARS1$coefficients["C"]
dXdg<-mARS1$coefficients["bvs"]
Zt0<-mean(females$z[which(females$t==(tempus-1))])
kt0<-mean(females$C[which(females$t==(tempus-1))])
gt0<-mean(females$bvs[which(females$t==(tempus-1))])
Zt1<-mean(females$z[which(females$t==tempus)])
kt1<-mean(females$C[which(females$t==tempus)])
gt1<-mean(females$bvs[which(females$t==tempus)])
Xttt<-mean(females$ARS[which(females$t==(tempus-1))]) # not exactly exp(intercept+Zt0*dXdz+kt0*dXdk) I do not want to account for the interaction (??) as it is problematic for XtT and XTt
XTTT<-mean(females$ARS[which(females$t==tempus)])# not exactly exp(intercept+Zt1*dXdz+kt1*dXdk) I do not want to account for the interaction (??) as it is problematic for XtT and XTt
XttT<-exp(intercept+Zt0*dXdz+gt0*dXdg+kt1*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
XtTt<-exp(intercept+Zt0*dXdz+gt1*dXdg+kt0*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
XtTT<-exp(intercept+Zt0*dXdz+gt1*dXdg+kt1*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
XTtt<-exp(intercept+Zt1*dXdz+gt0*dXdg+kt0*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
XTtT<-exp(intercept+Zt1*dXdz+gt0*dXdg+kt1*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
XTTt<-exp(intercept+Zt1*dXdz+gt1*dXdg+kt0*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
AX<-as.data.frame(matrix(data=c(Xttt,XttT,XtTt,XtTT,XTtt,XTtT,XTTt,XTTT,0,1,0,1,0,0,1,1),ncol=4))
AX<-data.frame(c(Xttt,XttT,XtTt,XtTT,XTtt,XTtT,XTTt,XTTT),c(0,0,0,0,1,1,1,1),c(0,0,1,1,0,0,1,1),c(0,1,0,1,0,1,0,1))
names(AX)<-c("X","Z","G","K")
m1X<-(lm(X~Z+G+K,data=AX))
evol[tempus-1]<-m1X$coefficients["G"]
plas[tempus-1]<-m1X$coefficients["Z"]
ecol[tempus-1]<-m1X$coefficients["Z"]
}
evol/sd(evol)
sd(evol)
plot(log(tapply(X=females$ARS,INDEX=females$t,FUN=mean)),ylim=c(-5,6),type="b")#log to see better what is going on at g13
points(evol,x=2:30-0.5,type="l",col="red")
points(plas,x=2:30-0.5,type="l",col="purple")
points(ecol,x=2:30-0.5,type="l",col="blue")
evol<-vector(length=max(females$t)-1)
plas<-vector(length=max(females$t)-1)
ecol<-vector(length=max(females$t)-1)
for (tempus in 2:max(females$t))
{
mARS1<-glm(ARS~1+C+z+bvs,data=females[which(females$t==(tempus-1) | females$t==tempus),],family=poisson)
intercept<-mARS0$coefficients[1]
dXdz<-mARS1$coefficients["z"]
dXdk<-mARS1$coefficients["C"]
dXdg<-mARS1$coefficients["bvs"]
Zt0<-mean(females$z[which(females$t==(tempus-1))])
kt0<-mean(females$C[which(females$t==(tempus-1))])
gt0<-mean(females$bvs[which(females$t==(tempus-1))])
Zt1<-mean(females$z[which(females$t==tempus)])
kt1<-mean(females$C[which(females$t==tempus)])
gt1<-mean(females$bvs[which(females$t==tempus)])
Xttt<-mean(females$ARS[which(females$t==(tempus-1))]) # not exactly exp(intercept+Zt0*dXdz+kt0*dXdk) I do not want to account for the interaction (??) as it is problematic for XtT and XTt
XTTT<-mean(females$ARS[which(females$t==tempus)])# not exactly exp(intercept+Zt1*dXdz+kt1*dXdk) I do not want to account for the interaction (??) as it is problematic for XtT and XTt
XttT<-exp(intercept+Zt0*dXdz+gt0*dXdg+kt1*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
XtTt<-exp(intercept+Zt0*dXdz+gt1*dXdg+kt0*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
XtTT<-exp(intercept+Zt0*dXdz+gt1*dXdg+kt1*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
XTtt<-exp(intercept+Zt1*dXdz+gt0*dXdg+kt0*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
XTtT<-exp(intercept+Zt1*dXdz+gt0*dXdg+kt1*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
XTTt<-exp(intercept+Zt1*dXdz+gt1*dXdg+kt0*dXdk)#this is done with population mean assumption. Would be impossible on an individual basis
AX<-as.data.frame(matrix(data=c(Xttt,XttT,XtTt,XtTT,XTtt,XTtT,XTTt,XTTT,0,1,0,1,0,0,1,1),ncol=4))
AX<-data.frame(c(Xttt,XttT,XtTt,XtTT,XTtt,XTtT,XTTt,XTTT),c(0,0,0,0,1,1,1,1),c(0,0,1,1,0,0,1,1),c(0,1,0,1,0,1,0,1))
names(AX)<-c("X","Z","G","K")
m1X<-(lm(X~Z+G+K,data=AX))
evol[tempus-1]<-m1X$coefficients["G"]
plas[tempus-1]<-m1X$coefficients["Z"]
ecol[tempus-1]<-m1X$coefficients["K"]
}
plot(log(tapply(X=females$ARS,INDEX=females$t,FUN=mean)),ylim=c(-5,6),type="b")#log to see better what is going on at g13
points(evol,x=2:30-0.5,type="l",col="red")
points(plas,x=2:30-0.5,type="l",col="purple")
points(ecol,x=2:30-0.5,type="l",col="blue")
points(abs(evol/(ecol+plas),x=2:30-0.5,type="l",col="green")
points(abs(evol/(ecol+plas)),x=2:30-0.5,type="l",col="green")
points(abs(evol/(ecol+plas)),x=2:30-0.5,type="l",col="green")
abs(evol/(ecol+plas))
mean(abs(evol/(ecol+plas)))
mean(abs(evol)/(abs(ecol)+abs(plas)))
plot(log(tapply(X=females$ARS,INDEX=females$t,FUN=mean)),ylim=c(-5,6),type="b")#log to see better what is going on at g13
points(evol,x=2:30-0.5,type="l",col="red")
points(plas,x=2:30-0.5,type="l",col="purple")
points(ecol,x=2:30-0.5,type="l",col="blue")
points(abs(evol)/(abs(ecol)+abs(plas)),x=2:30-0.5,type="l",col="green")
plot(abs(evol)/(abs(ecol)+abs(plas)),x=2:30-0.5,type="l",col="green")
plot(abs(evol)/(abs(ecol)+abs(plas)),x=2:30-0.5,type="l",col="green",ylim=c(0,1))
plot(abs(evol)/(abs(ecol)+abs(plas)+abs(evol)),x=2:30-0.5,type="l",col="green",ylim=c(0,1))
plot(abs(evol)/(abs(ecol)+abs(plas)+abs(evol)),x=2:30-0.5,type="l",col="red",ylim=c(0,1))
points(abs(plas)/(abs(ecol)+abs(plas)+abs(evol)),x=2:30-0.5,type="l",col="purple")
plot(abs(ecol)/(abs(ecol)+abs(plas)+abs(evol)),x=2:30-0.5,type="l",col="blue")
plot(abs(evol)/(abs(ecol)+abs(plas)+abs(evol)),x=2:30-0.5,type="l",col="red",ylim=c(0,1))
points(abs(plas)/(abs(ecol)+abs(plas)+abs(evol)),x=2:30-0.5,type="l",col="purple")
points(abs(ecol)/(abs(ecol)+abs(plas)+abs(evol)),x=2:30-0.5,type="l",col="blue")
View(popfile)
plot(popfile$bvs,x=popfile$t)#there is not much genetic variance left after 15 years!
sd(evol)
=======
age=10
size=10
sizedeviation<-size-MeanBirthSize
p<-0.6*exp(-age/4)+(-1+exp(age*log(2)/20))
p[p>1]<-1
if(p<1)#size does not prevent animals of maximal age to die
{
plogit<-log(p/(1-p))
Philogit<-plogit-SurvivalSelection1*sizedeviation-SurvivalSelection2*sizedeviation^2
p<-exp(Philogit)/(1+exp(Philogit))
}
p
bathtub<-function(age,size){
sizedeviation<-size-MeanBirthSize
p<-0.6*exp(-age/4)+(-1+exp(age*log(2)/20))
p[p>1]<-1
if(p<1)#size does not prevent animals of maximal age to die
{
plogit<-log(p/(1-p))
Philogit<-plogit-SurvivalSelection1*sizedeviation-SurvivalSelection2*sizedeviation^2
p<-exp(Philogit)/(1+exp(Philogit))
}
return(p)
}
sizes<-seq(2,10,by=0.1)
phi<-cbind(sizes,rep(NA,length(sizes)))
for (size in 1:length(sizes))
{
phi[size,2]<-bathtub(age,sizes[size])
}
plot(phi[,1],phi[,2])
sizes<-seq(2,10,by=0.1)
phi<-cbind(sizes,rep(NA,length(sizes)))
for (size in 1:length(sizes))
{
phi[size,2]<-1-bathtub(age,sizes[size])
}
plot(phi[,1],phi[,2])
runif(1,1,1.2)
mean(runif(1000,1,1.2))
mean(runif(100000,1,1.2))
meanGrowth<-mean(runif(10000,lowBoundGrowth,highBoundGrowth))
lowBoundGrowth<-1
highBoundGrowth<-1.2
meanGrowth<-mean(runif(10000,lowBoundGrowth,highBoundGrowth))
sizedeviation<-size-(MeanBirthSize*meanGrowth^age)
sizedeviation
(MeanBirthSize*meanGrowth^age)
size
size=10
sizedeviation<-size-(MeanBirthSize*meanGrowth^age)
sizedeviation
meanGrowth^age
source('~/GitHub/Dataset.R/data.R', echo=TRUE)
sizeDeviation<-Object@size-MeanBirthSize*meanGrowth^Object@age
lambda<-exp(log(MeanRepro)+fertilitySelection1*sizeDeviation+fertilitySelection2*sizeDeviation^2
source('~/.active-rstudio-document', echo=TRUE)
sizeDeviation<-seq(-2,2,0.1)
lambda<-exp(log(MeanRepro)+fertilitySelection1*sizeDeviation+fertilitySelection2*sizeDeviation^2)
repro<-rpois(n=1,lambda=lambda)
plot(repro,sizeDeviation)
sizeDeviation<-seq(-2,2,0.1)
lambda<-exp(log(MeanRepro)+fertilitySelection1*sizeDeviation+fertilitySelection2*sizeDeviation^2)
plot(lambda,sizeDeviation)
mean(lambda)
lambda<-exp(log(MeanRepro)+0.1*sizeDeviation-0.01*sizeDeviation^2)
plot(lambda,sizeDeviation)
mean(lambda)
source('~/GitHub/Dataset.R/data.R', echo=TRUE)
source('~/GitHub/Dataset.R/data.R', echo=TRUE)
popfile<-read.table(file="pop.csv",header=T)
plot(popfile$z,x=popfile$age)
set.seed(12)
source('~/.active-rstudio-document', echo=TRUE)
popfile<-read.table(file="pop.csv",header=T)
plot(popfile$z,x=popfile$age)
source('~/.active-rstudio-document', echo=TRUE)
popfile<-read.table(file="pop.csv",header=T)
plot(popfile$z,x=popfile$age)
source('~/.active-rstudio-document', echo=TRUE)
nbIndividuals<-100
meanInds<-vector(length=nbIndividuals) # just a basic draw of individual genotypic values
for (beast in 1:nbIndividuals)
{
ind<-vector(length=0)
for (L in 1:nbLoci)
{
allele1<-floor(runif(n=1,min=1,max=nbAlleles+1))
allele2<-floor(runif(n=1,min=1,max=nbAlleles+1))
ind<-c(ind,gvalues[L,allele1,allele2])
}
meanInds[beast]<-mean(ind)
}
plot(meanInds) # and a visualisation of it
mean(meanInds)
var(meanInds)
nbIndividuals<-100
meanInds<-vector(length=nbIndividuals) # just a basic draw of individual genotypic values
for (beast in 1:nbIndividuals)
{
ind<-vector(length=0)
for (L in 1:nbLoci)
{
allele1<-floor(runif(n=1,min=1,max=nbAlleles+1))
allele2<-floor(runif(n=1,min=1,max=nbAlleles+1))
ind<-c(ind,gvalues[allele1,allele2,L])
}
meanInds[beast]<-mean(ind)
}
plot(meanInds) # and a visualisation of it
mean(meanInds)
var(meanInds)
nbIndividuals<-100
meanInds<-vector(length=nbIndividuals) # just a basic draw of individual genotypic values
for (beast in 1:nbIndividuals)
{
ind<-vector(length=0)
for (L in 1:nbLoci)
{
allele1<-floor(runif(n=1,min=1,max=nbAlleles+1))
allele2<-floor(runif(n=1,min=1,max=nbAlleles+1))
ind<-c(ind,gvalues[allele1,allele2,L])
}
meanInds[beast]<-sum(ind)
}
plot(meanInds) # and a visualisation of it
mean(meanInds)
var(meanInds)
source('~/GitHub/Dataset.R/data.R', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
popfile<-read.table(file="pop.csv",header=T)
plot(popfile$z,x=popfile$age)
library(lme4)
mm0<-lmer(z~1+age+s+(1|ID),data=popfile)
summary(mm0)
mm0<-lmer(z~1+age+t+s+(1|ID),data=popfile)
summary(mm0)
dat<-read.table(file="pop.csv",header=T)
head(dat,5)
which(!(min(dat$ID):max(dat$ID)%in%dat$ID))
dat2<-dat[,c("ID","t","z")]
library('reshape')
dat3<-reshape(dat2, idvar = "ID", timevar = "t", direction = "wide")
temp<-dat[,c(-1,-3,-5)]
temp<-temp[!duplicated(temp),]
dat4<-merge(dat3,temp,by="ID")
dat4
dat<-read.table(file="pop.csv",header=T)
dat
dat$r<-dat(dat$t==dat$t+1 & (dat$p1==dat$ID | dat$p2==dat$ID))
r<-dat[dat$t==dat$t+1 & (dat$p1==dat$ID | dat$p2==dat$ID),]
r
r<-c()
for(i in 1:length(dat$t)){
r[i]<-dim(dat[dat$t==dat$t+1 & (dat$p1==dat$ID | dat$p2==dat$ID),])[1]
}
r<-c()
for(i in 1:length(dat$t)){
r[i]<-dim(dat[dat$t[i]==dat$t+1 & (dat$p1==dat$ID[i] | dat$p2==dat$ID[i]),])[1]
}
r
dat$R<-r
dat
r<-c()
for(i in 1:length(dat$t)){
r[i]<-dim(dat[dat$t[i]+1==dat$t & (dat$p1==dat$ID[i] | dat$p2==dat$ID[i]),])[1]
}
dat$R<-r
dat
?dim
r<-c()
for(i in 1:length(dat$t)){
r[i]<-nrow(dat[dat$t[i]+1==dat$t & (dat$p1==dat$ID[i] | dat$p2==dat$ID[i]),])
}
dat$R<-r
dat
r<-c()
for(i in 1:length(dat$t)){
r[i]<-nrow(dat[(dat$t[i]+1==dat$t & (dat$p1==dat$ID[i] | dat$p2==dat$ID[i])),])
}
dat$R<-r
dat
i<-1
dat[(dat$t[i]+1==dat$t & (dat$p1==dat$ID[i] | dat$p2==dat$ID[i])),]
r<-c()
for(i in 1:length(dat$t)){
r[i]<-nrow(dat[((dat$t[i]+1)==dat$t & (dat$p1==dat$ID[i] | dat$p2==dat$ID[i])),])
}
dat$R<-r
dat
r<-c()
for(i in 1:length(dat$t)){
r[i]<-nrow(dat[((dat$t[i]+1)==dat$t && (dat$p1==dat$ID[i] | dat$p2==dat$ID[i])),])
}
dat$R<-r
dat
i
i<-1
dat$p1==dat$ID[i] | dat$p2==dat$ID[i]
(dat$p1==dat$ID[i] | dat$p2==dat$ID[i])
dat$ID[i]
dat$p1==1
dat$p2==1
dat
dat<-read.table(file="pop.csv",header=T)
dat
dat<-read.table(file="pop.csv",header=T)
head(dat,5)
which(!(min(dat$ID):max(dat$ID)%in%dat$ID))
r<-c()
for(i in 1:length(dat$t)){
r[i]<-nrow(dat[((dat$t[i]+1)==dat$t && (dat$p1==dat$ID[i] | dat$p2==dat$ID[i])),])
}
dat$R<-r
dat
i<-5
nrow(dat[((dat$t[i]+1)==dat$t && (dat$p1==dat$ID[i] | dat$p2==dat$ID[i])),])
dat$ID[i]
dat$p1==5
dat[((dat$t[i]+1)==dat$t && (dat$p1==dat$ID[i] | dat$p2==dat$ID[i])),]
dat[((dat$t[i]+1)==dat$t & (dat$p1==dat$ID[i] | dat$p2==dat$ID[i])),]
dat
r<-c()
for(i in 1:length(dat$t)){
r[i]<-nrow(dat[(dat$t[i]==dat$t && ((dat$p1==dat$ID[i] &!is.na(dat$p1)) | (dat$p2==dat$ID[i] & !is.na(dat$p2)))),])
}
dat$R<-r
dat
r<-c()
for(i in 1:length(dat$t)){
r[i]<-nrow(dat[(dat$t[i]==dat$t & ((dat$p1==dat$ID[i] &!is.na(dat$p1)) | (dat$p2==dat$ID[i] & !is.na(dat$p2)))),])
}
dat$R<-r
dat
setClass(
Class="Leprechaun",
representation=representation(
ID = "integer",
pID = "integer",
age = "integer",
Birth = "integer",
alive = "logical",
size = "numeric",
camemberts = "integer",
sex = "character",
DNA = "matrix",
bvs = "numeric",
ARS = "integer"
)
)
############### Definition of the basic methods (for printing to the screen and initialisation)
###############################################################################################
setMethod("show","Leprechaun",
function(object){
cat(object@ID,"\t",object@size,"\t",object@camemberts,"\t",object@age,"\t",object@sex,"\t(",object@pID[1],",",object@pID[2],")\t",object@Birth,"\t",object@alive,"\n",sep="")
}
)
setMethod("initialize","Leprechaun",function(.Object,parent1,parent2){
.Object@DNA<-matrix(NA,nrow=2,ncol=nbLoci)
if(missing(parent1)){
parent1<-NA
#weight1<-MeanBirthSize+2*runif(1)
.Object@DNA[1,]<-floor(runif(nbLoci,min=1,max=nbAlleles+1))
}else{
weight1<-pop[[parent1]]@size
.Object@DNA[1,]<-pop[[parent1]]@DNA[cbind(floor(runif(n=nbLoci,min=1,max=3)),1:nbLoci)]
}
if(missing(parent2)){
parent2<-NA
#weight2<-MeanBirthSize+2*runif(1)
.Object@DNA[2,]<-floor(runif(nbLoci,min=1,max=nbAlleles+1))
}else{
#weight2<-pop[[parent2]]@size
.Object@DNA[2,]<-pop[[parent2]]@DNA[cbind(floor(runif(n=nbLoci,min=1,max=3)),1:nbLoci)]
}
.Object@age<-as.integer(0)
.Object@ID<-CID
.Object@pID<-c(as.integer(parent1),as.integer(parent2))
.Object@Birth<-as.integer(YR)
.Object@alive<-TRUE
#.Object@size<-0.5*weight1+0.5*weight2
BreedingValueSize<-0
for (Locus in 1:nbLoci)#take the mean of genetic values
{
BreedingValueSize<-BreedingValueSize+(gvalues[ .Object@DNA[1,Locus], .Object@DNA[2,Locus], Locus]/nbLoci)
}
.Object@bvs<-BreedingValueSize
size<-MeanBirthSize+BreedingValueSize
.Object@size<-rnorm(n=1,mean=size,sd=1)
.Object@camemberts<-as.integer(0)
.Object@ARS<-as.integer(0)#annual reproductive success
if(runif(1)>0.5){.Object@sex<-'F'}else{.Object@sex<-'M'}
CID<<-as.integer(CID+1)
return(.Object)
})
new("Leprechaun")
##### In this file we will try to come up with some things ####
###############################################################
########################
####### Type of program
## Written in R
## Object Oriented
#######################
#######################
# Main object "Leprechaun": an individual of our species of interest, the Irish Leprechaun, small in size, but with great powers. To make it more French for Timothee, we assume that their favourite food is camembert. Leprechaun is not very choosy, and mates completely random.
##########################################
# The object contains the following values
# Static [these numbers do not change after initialisation]
#  V ID (unique identifier number) [integer]
#  V pID (two numbers referring to the parents of the Leprechaun, if none: NA) [vector of two integers]
#  V Year of birth (timestep at which the individual was born)	[integer]
#  (- Genome (?) (two vectors of length N coding for both chromosomes of N loci in the genome.) [two vectors of N integers]
#  - Heritable phenotypic trait value of interest (z) (e.g. birth weight) (changes/constant through life depending on trait)
#  - (Possibly: breeding value A))
#  - Rather simulate physically independent loci, otherwise we need to simulate recombination on the chromosomes. Over short time periods, 100 recombinations fragments (ie independent loci) sounds realistic.
#  - Explicit coding of traits by many independent diploid loci. The simplest model: z = mean + sum_loci(a1_locus + a2_locus) + environment. One can add explicit dominance and epistasis, as well as interactions with environment.
#  - A possibility is to draw the a of the different alleles from a N(0,V). Each locus can have a different V, and thus a different importance.
#  - A large number of loci (>20) will give easily patterns expected from quantitative genetics. We can draw randomly the number of loci per trait.
#  - My main concern at the moment is the initialisation of the genetic diversity: it will be hard to avoid a fast decline of diversity at the beginning. One possibility is using neutral expectations of diversity (n-coalescent or Ewens distribution)
#  - We probably do not need mutations if we consider a population over no more than some tens of generations.
#  V Sex (M/F). Could be genetically determined by on locus, thus allowing random fluctuations of sex ratio and thus population structure.
# Dynamic [these numbers do change after initialisation]
#  V alive (boolean, true/false) [boolean]
#  V age (a) (timesteps since birth) [integer]
#  - stage (possibly instead of/in addition to age) (juvenile, adult, etc)
#  V size (x)
####################
###### Relations that need to be defined between size (x), age (a), trait (z) and vital rates
# (- Possibly include population density d in functions)
# V Survival(a,x,z,d) (logistic function)
# - Growth (a,x,z,d) (either transition probability to next stage or absolute growth)
# - Reproduction probability: p_repr(a,x,z,d) (logistic function)
# - Number of offspring: n_offspring(a,x,z,d) (poisson distribution)
# - Offspring size x distribution: x_offspring(x_mother,z_mother,x_father,z_father) (not required if working with stages) (prability density function)
# - Offspring trait z distribution: z_offspring(x_mother,z_mother,x_father,z_father,A_mother,A_father) + rnorm(0,V_E) (prability density function)
# - For survival and reproduction, we can consider functions of the form W=exp(-((z-Optimum)^2)/(2*width)), that is, gaussian stabilizing selection. We could then let the Optimum shift.
####################
####### Environmental aspects
# - Extra variation in z due to unexplained factors (i.e. V_E)) (assumed constant over time and constant accross all individuals)
# - Changes in the environment affecting survival(x,z), growth(x,z), p_repr(x,z), n_offspring(x,z), f_offspring(x_mother,z_mother) (i.e. changing selection)
########################
########## 'Settings' of ancestral population from which simulation can start:
# - n start individuals
# - Start trait z distribution
# - Start age (/stage) distribution
# - Assign sexes to individuals
# - (Possibly: start a values)
########## Perform in each time step the following actions over all alive individuals at t=0
## In following order:
# survival(x,z)
### For those who survive:
# growth(x,z)
# p_repr(x,z)
### For those who reproduce:
# Random mating between all reproductive males and females
# n_offspring(x,z)
# x_offspring(x_mother,z_mother,x_father,z_father)
# z_offspring(x_mother,z_mother,x_father,z_father,a_mother,a_father,m) + rnorm(0,V_E)
# Random sex assigned to offspring
# Offspring added to population
### End of timestep
####################################################
################ GLOBAL VARIABLES AND COUNTERS #####
####################################################
################ Random seed #######################
set.seed(12)
################ Counter for the IDs ###############
CID<-as.integer(1)
################ Counter for the current year ######
YR<-0
################ Base population parameters ########
MeanBirthSize<-10
lowBoundGrowth<-1 # minimal growth rate
highBoundGrowth<-1.1 # maximal growth rate
meanGrowth<-mean(runif(10000,lowBoundGrowth,highBoundGrowth)) # needed to make survival ~ size relative on age
MeanRepro<-2
################ Environmental parameters ##########
MeanCamembert<-5000
SDCamembert<-1000
############### Genetic determinism ################
dominance<-1 # for additive effects only, must be 0
overdominance<-0 # non-null values generate overdominance
nbLoci<-10 #number of loci controling the trait phenotype
nbAlleles<-10 #number of existing alleles per loci
gvalues<-array(data=NA,dim=c(nbAlleles,nbAlleles,nbLoci),dimnames=list(paste("A",1: nbAlleles,sep=""),paste("A",1: nbAlleles,sep=""),paste("L",1:nbLoci,sep=""))) # Initialising a matrix that will contain the genotypic effects on the/a trait
for(L in 1:nbLoci)
{
# Setting the effects for the homozygotes [all loci]
effect<-abs(rnorm(n=1,mean=0,sd=1))# alter the locus importance in a realistic way (many small-effect loci, few major loci)
diag(gvalues[,,L])<-2*rnorm(n=dim(gvalues)[1],mean=0,sd=effect)
# Setting the effects for the heterozygotes
for(A in 1:(nbAlleles-1))# loop for off-diagonal = heterozygotes (additive and dominance effects)
{
for (D in (A+1):nbAlleles)
{
d<-dominance*runif(n=1,min=-0.5-overdominance,max=0.5+overdominance)
gvalues[A,D,L]<-(0.5-d)*gvalues[A,A,L]+(0.5+d)*gvalues[D,D,L] # mean of additive effects + dominance, over diagonal
gvalues[D,A,L]<-(0.5-d)*gvalues[A,A,L]+(0.5+d)*gvalues[D,D,L] # the same below diagonal
}
}
}
############### Selection parameters ###############
SurvivalSelection1<-0.1 #linear coefficient on a logit scale for Survival ~ ... + size +size^2
SurvivalSelection2<-(-0.01) #quadratic coefficient on a logit scale for Survival ~ ... + size + size^2; negative value=balancing selection
fertilitySelection1<-0.1 #linear coefficient on a log scale for reproduction ~ ... + size + size^2
fertilitySelection2<-(-0.01) #quadratic coefficient on a log scale for reproduction ~ ... + size + size^2; negative value=balancing selection
camembertSelection<-0.1
survivalPenaltyForRepro<-0
####################################################
####################################################
############### Definition of the class ############
####################################################
setClass(
Class="Leprechaun",
representation=representation(
ID = "integer",
pID = "integer",
age = "integer",
Birth = "integer",
alive = "logical",
size = "numeric",
camemberts = "integer",
sex = "character",
DNA = "matrix",
bvs = "numeric",
ARS = "integer"
)
)
############### Definition of the basic methods (for printing to the screen and initialisation)
###############################################################################################
setMethod("show","Leprechaun",
function(object){
cat(object@ID,"\t",object@size,"\t",object@camemberts,"\t",object@age,"\t",object@sex,"\t(",object@pID[1],",",object@pID[2],")\t",object@Birth,"\t",object@alive,"\n",sep="")
}
)
setMethod("initialize","Leprechaun",function(.Object,parent1,parent2){
.Object@DNA<-matrix(NA,nrow=2,ncol=nbLoci)
if(missing(parent1)){
parent1<-NA
#weight1<-MeanBirthSize+2*runif(1)
.Object@DNA[1,]<-floor(runif(nbLoci,min=1,max=nbAlleles+1))
}else{
weight1<-pop[[parent1]]@size
.Object@DNA[1,]<-pop[[parent1]]@DNA[cbind(floor(runif(n=nbLoci,min=1,max=3)),1:nbLoci)]
}
if(missing(parent2)){
parent2<-NA
#weight2<-MeanBirthSize+2*runif(1)
.Object@DNA[2,]<-floor(runif(nbLoci,min=1,max=nbAlleles+1))
}else{
#weight2<-pop[[parent2]]@size
.Object@DNA[2,]<-pop[[parent2]]@DNA[cbind(floor(runif(n=nbLoci,min=1,max=3)),1:nbLoci)]
}
.Object@age<-as.integer(0)
.Object@ID<-CID
.Object@pID<-c(as.integer(parent1),as.integer(parent2))
.Object@Birth<-as.integer(YR)
.Object@alive<-TRUE
#.Object@size<-0.5*weight1+0.5*weight2
BreedingValueSize<-0
for (Locus in 1:nbLoci)#take the mean of genetic values
{
BreedingValueSize<-BreedingValueSize+(gvalues[ .Object@DNA[1,Locus], .Object@DNA[2,Locus], Locus]/nbLoci)
}
.Object@bvs<-BreedingValueSize
size<-MeanBirthSize+BreedingValueSize
.Object@size<-rnorm(n=1,mean=size,sd=1)
.Object@camemberts<-as.integer(0)
.Object@ARS<-as.integer(0)#annual reproductive success
if(runif(1)>0.5){.Object@sex<-'F'}else{.Object@sex<-'M'}
CID<<-as.integer(CID+1)
return(.Object)
})
new("Leprechaun")
b<-new("Leprechaun")
b@ID
b@sex
dat<-read.table(file="pop.csv",header=T)
head(dat,5)
temp<-dat[,!c("t","z")]
temp<-dat[,-c("t","z")]
dat2<-dat[,c("ID","t","z")]
dat3<-reshape(dat2, idvar = "ID", timevar = "t", direction = "wide")
dat3
head(dat)
dat2<-subset(dat,phi==1)
dat2<-dat[,c("ID","t","z")]
dat3<-reshape(dat2, idvar = "ID", timevar = "t", direction = "wide")
dat3
dat2<-subset(dat,dat$phi==1)
dat2<-dat[,c("ID","t","z")]
dat3<-reshape(dat2, idvar = "ID", timevar = "t", direction = "wide")
dat3
dat2
dat[dat$ID==2,]
dat2[dat2$ID==2]
dat2[dat2$ID==2,]
?subset
head(dat)
dat2<-subset(dat,phi==1)
dat2<-subset(dat,phi==1)
dat2<-dat2[,c("ID","t","z")]
library('reshape')
dat3<-reshape(dat2, idvar = "ID", timevar = "t", direction = "wide")
dat3
for(i in 2:(ncol(dat3)-2)){
plot(dat3[,i],dat3[,i+1],na.rm=TRUE)
}
warnings()
for(i in 2:(ncol(dat3)-2)){
plot(dat3[,i],dat3[,i+1])
}
>>>>>>> e879439788da385607dad24ca553ec532ab8a511
