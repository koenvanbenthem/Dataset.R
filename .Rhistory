# fold equal to their slave number.
# Assumes: thedata,fold,foldNumber,p
foldslave <- function() {
# Note the use of the tag for sent messages:
#     1=ready_for_task, 2=done_task, 3=exiting
# Note the use of the tag for received messages:
#     1=task, 2=done_tasks
junk <- 0
done <- 0
while (done != 1) {
# Signal being ready to receive a new task
mpi.send.Robj(junk,0,1)
# Receive a task
task <- mpi.recv.Robj(mpi.any.source(),mpi.any.tag())
task_info <- mpi.get.sourcetag()
tag <- task_info[2]
if (tag == 1) {
foldNumber <- task$foldNumber
rss <- double(p)
for (i in 1:p) {
# produce a linear model on the first i variables on
# training data
templm <- lm(y~.,data=thedata[fold!=foldNumber,1:(i+1)])
# produce predicted data from test data
yhat <- predict(templm,newdata=thedata[fold==foldNumber,1:(i+1)])
# get rss of yhat-y
localrssresult <- sum((yhat-thedata[fold==foldNumber,1])^2)
rss[i] <- localrssresult
}
# Send a results message back to the master
results <- list(result=rss,foldNumber=foldNumber)
mpi.send.Robj(results,0,2)
}
else if (tag == 2) {
done <- 1
}
# We'll just ignore any unknown messages
}
mpi.send.Robj(junk,0,3)
}
# We're in the parent.
# first make some data
n <- 1000  # number of obs
p <- 30		# number of variables
# Create data as a set of n samples of p independent variables,
# make a "random" beta with higher weights in the front.
# Generate y's as y = beta*x + random
x <- matrix(rnorm(n*p),n,p)
beta <- c(rnorm(p/2,0,5),rnorm(p/2,0,.25))
y <- x %*% beta + rnorm(n,0,20)
thedata <- data.frame(y=y,x=x)
fold <- rep(1:10,length=n)
fold <- sample(fold)
summary(lm(y~x))
# Now, send the data to the slaves
mpi.bcast.Robj2slave(thedata)
mpi.bcast.Robj2slave(fold)
mpi.bcast.Robj2slave(p)
# Send the function to the slaves
mpi.bcast.Robj2slave(foldslave)
# Call the function in all the slaves to get them ready to
# undertake tasks
mpi.bcast.cmd(foldslave())
# Create task list
tasks <- vector('list')
for (i in 1:10) {
tasks[[i]] <- list(foldNumber=i)
}
# Create data structure to store the results
rssresult = matrix(0,p,10)
junk <- 0
closed_slaves <- 0
n_slaves <- mpi.comm.size()-1
while (closed_slaves < n_slaves) {
# Receive a message from a slave
message <- mpi.recv.Robj(mpi.any.source(),mpi.any.tag())
message_info <- mpi.get.sourcetag()
slave_id <- message_info[1]
tag <- message_info[2]
if (tag == 1) {
# slave is ready for a task. Give it the next task, or tell it tasks
# are done if there are none.
if (length(tasks) > 0) {
# Send a task, and then remove it from the task list
mpi.send.Robj(tasks[[1]], slave_id, 1);
tasks[[1]] <- NULL
}
else {
mpi.send.Robj(junk, slave_id, 2)
}
}
else if (tag == 2) {
# The message contains results. Do something with the results.
# Store them in the data structure
foldNumber <- message$foldNumber
rssresult[,foldNumber] <- message$result
}
else if (tag == 3) {
# A slave has closed down.
closed_slaves <- closed_slaves + 1
}
}
# plot the results
plot(apply(rssresult,1,mean))
mpi.close.Rslaves()
mpi.quit(save="no")
##### In this file we will try to come up with some things ####
###############################################################
########################
####### Type of program
## Written in R
## Object Oriented
## Uses parallel computations with library("Rmpi")
#######################
#######################
# Main object "Leprechaun": an individual of our species of interest, the Irish Leprechaun, small in size, but with great powers. To make it more French for Timothee, we assume that their favourite food is camembert. Leprechaun is not very choosy, and mates completely random.
##########################################
# The object contains the following values
# Static [these numbers do not change after initialisation]
#  V ID (unique identifier number) [integer]
#  V pID (two numbers referring to the parents of the Leprechaun, if none: NA) [vector of two integers]
#  V Year of birth (timestep at which the individual was born)	[integer]
#  V Genome (?) (two vectors of length N coding for both chromosomes of N loci in the genome.) [two vectors of N integers]
#  V Heritable phenotypic trait value of interest (z) (e.g. birth weight) (changes/constant through life depending on trait)
#  - (Possibly: breeding value A))
#  - Rather simulate physically independent loci, otherwise we need to simulate recombination on the chromosomes. Over short time periods, 100 recombinations fragments (ie independent loci) sounds realistic.
#  V Explicit coding of traits by many independent diploid loci. The simplest model: z = mean + sum_loci(a1_locus + a2_locus) + environment. One can add explicit dominance and epistasis, as well as interactions with environment.
#  - A possibility is to draw the a of the different alleles from a N(0,V). Each locus can have a different V, and thus a different importance.
#  - A large number of loci (>20) will give easily patterns expected from quantitative genetics. We can draw randomly the number of loci per trait.
#  - My main concern at the moment is the initialisation of the genetic diversity: it will be hard to avoid a fast decline of diversity at the beginning. One possibility is using neutral expectations of diversity (n-coalescent or Ewens distribution)
#  - We probably do not need mutations if we consider a population over no more than some tens of generations.
#  V Sex (M/F). Could be genetically determined by on locus, thus allowing random fluctuations of sex ratio and thus population structure.
# Dynamic [these numbers do change after initialisation]
#  V alive (boolean, true/false) [boolean]
#  V age (a) (timesteps since birth) [integer]
#  - stage (possibly instead of/in addition to age) (juvenile, adult, etc)
#  V size (x)
####################
###### Relations that need to be defined between size (x), age (a), trait (z) and vital rates
# (- Possibly include population density d in functions)
# V Survival(a,x,z,d) (logistic function)
# - Growth (a,x,z,d) (either transition probability to next stage or absolute growth)
# - Reproduction probability: p_repr(a,x,z,d) (logistic function)
# - Number of offspring: n_offspring(a,x,z,d) (poisson distribution)
# - Offspring size x distribution: x_offspring(x_mother,z_mother,x_father,z_father) (not required if working with stages) (prability density function)
# - Offspring trait z distribution: z_offspring(x_mother,z_mother,x_father,z_father,A_mother,A_father) + rnorm(0,V_E) (prability density function)
# - For survival and reproduction, we can consider functions of the form W=exp(-((z-Optimum)^2)/(2*width)), that is, gaussian stabilizing selection. We could then let the Optimum shift.
####################
####### Environmental aspects
# - Extra variation in z due to unexplained factors (i.e. V_E)) (assumed constant over time and constant accross all individuals)
# - Changes in the environment affecting survival(x,z), growth(x,z), p_repr(x,z), n_offspring(x,z), f_offspring(x_mother,z_mother) (i.e. changing selection)
########################
########## 'Settings' of ancestral population from which simulation can start:
# - n start individuals
# - Start trait z distribution
# - Start age (/stage) distribution
# - Assign sexes to individuals
# - (Possibly: start a values)
########## Perform in each time step the following actions over all alive individuals at t=0
## In following order:
# survival(x,z)
### For those who survive:
# growth(x,z)
# p_repr(x,z)
### For those who reproduce:
# Random mating between all reproductive males and females
# n_offspring(x,z)
# x_offspring(x_mother,z_mother,x_father,z_father)
# z_offspring(x_mother,z_mother,x_father,z_father,a_mother,a_father,m) + rnorm(0,V_E)
# Random sex assigned to offspring
# Offspring added to population
### End of timestep
############### Setting folder for storage ###############
wd<-"/Users/koen/Dataset.R"
setwd(wd)
folder<-"Test2"
converter<-paste("Data/",folder,"/conv.csv",sep="")
dir.create(file.path("Data", folder))
################ Setting parameters ########################
norep<-1 # Number of replicates
SS1<-seq(1,5,1) # Linear survival selection
SS2<-c(-0.01) # Quadratic survival selection
fs1<-c(0.1) # Linear fertility selection
fs2<-c(-0.01) # Quadratic fertility selection
cs<-c(0.1) # Camembert selection
sdc<-c(1000) #SDcamembert
############### Creating all tasks #########################
tasks<-expand.grid(rep=1:norep,SS1=SS1,SS2=SS2,fs1=fs1,fs2=fs2,cs=cs,sdc=sdc)
tasks$seed<-sample(1:length(tasks$rep))
tasks$genseed<-rep(789,length(tasks$rep))
tasks$filename<-paste("Data/",folder,"/pop_seed_",tasks$seed,"genseed_",tasks$genseed,"SS1_",tasks$SS1*10,"_SS2_",tasks$SS2*100,"_FS1_",tasks$fs1*10,"_FS2_",tasks$fs2*100,"_CAMSEL_",tasks$cs*10,"_SDCAM_",tasks$sdc,".csv",sep="")
write.csv(tasks,file=converter)
############## Starting the slaves ######################
library("Rmpi")
############## Initialising the slaves by learning them the classes ####################
############## Performing the calculations ###################################
# Notice we just say "give us all the slaves you've got."
mpi.spawn.Rslaves()
if (mpi.comm.size() < 2) {
print("More slave processes are required.")
mpi.quit()
}
.Last <- function(){
if (is.loaded("mpi_initialize")){
if (mpi.comm.size(1) > 0){
print("Please use mpi.close.Rslaves() to close slaves.")
mpi.close.Rslaves()
}
print("Please use mpi.quit() to quit R")
.Call("mpi_finalize")
}
}
# Function the slaves will call to perform
slave <- function() {
# Note the use of the tag for sent messages:
#     1=ready_for_task, 2=done_task, 3=exiting
# Note the use of the tag for received messages:
#     1=task, 2=done_tasks
junk <- 0
done <- 0
while (done != 1) {
# Signal being ready to receive a new task
mpi.send.Robj(junk,0,1)
# Receive a task
task <- mpi.recv.Robj(mpi.any.source(),mpi.any.tag())
task_info <- mpi.get.sourcetag()
tag <- task_info[2]
if (tag == 1) {
set.seed(task$genseed)
cat(getwd(),file="bbbbb",append=TRUE)
#source("Genes.R")
set.seed(task$seed)
#source("Time.R")
} else if (tag == 2) {
done <- 1
}
# We'll just ignore any unknown messages
}
mpi.send.Robj(junk,0,3)
}
# Send the function to the slaves
mpi.bcast.Robj2slave(slave)
# Call the function in all the slaves to get them ready to
# undertake tasks
mpi.bcast.cmd(slave())
mpi.bcast.cmd(setwd(wd))
# Teach them what a leprechaun is
mpi.bcast.cmd(source("Leprechaun.R"))
junk <- 0
closed_slaves <- 0
n_slaves <- mpi.comm.size()-1
#convert the tasks data frame into a list
tasks<-split(tasks, rownames(tasks))
while (closed_slaves < n_slaves) {
# Receive a message from a slave
message <- mpi.recv.Robj(mpi.any.source(),mpi.any.tag())
message_info <- mpi.get.sourcetag()
slave_id <- message_info[1]
tag <- message_info[2]
if (tag == 1) {
# slave is ready for a task. Give it the next task, or tell it tasks
# are done if there are none.
if (length(tasks) > 0) {
# Send a task, and then remove it from the task list
mpi.send.Robj(tasks[[1]], slave_id, 1);
tasks[[1]] <- NULL
}
else {
mpi.send.Robj(junk, slave_id, 2)
}
}
else if (tag == 2) {
# The message contains results. Do something with the results.
# Store them in the data structure -- no, was already done before
}
else if (tag == 3) {
# A slave has closed down.
closed_slaves <- closed_slaves + 1
}
}
mpi.close.Rslaves()
mpi.quit(save="no")
source('~/GitHub/CarpentryExercise/S4imulations.R', echo=TRUE)
set.seed(12)
################ Counter for the IDs
CID<-as.integer(1)
################ Counter for the current year
YR<-0
################ Base population parameters
MeanBirthSize<-10
meanGrowth<-prod(runif(10000,lowBoundGrowth,highBoundGrowth))^(1/10000)
MeanRepro<-2
meanGrowth<-prod(runif(10000,0.9,1.2))^(1/10000)
################ Basic initializations ################
################ Random seed
set.seed(12)
################ Counter for the IDs
CID<-as.integer(1)
################ Counter for the current year
YR<-0
################ Base population parameters
MeanBirthSize<-10
meanGrowth<-prod(runif(10000,0.9,1.2))^(1/10000)
MeanRepro<-2
############### Genetic determinisms ###############
############### Genetic determinism Z
dominance<-1 # for additive effects only, must be 0
overdominance<-0 # non-null values generate overdominance
nbLoci<-10 #number of loci controling the trait phenotype
nbAlleles<-10 #number of existing alleles per loci
gvaluesZ<-array(data=NA,dim=c(nbAlleles,nbAlleles,nbLoci),dimnames=list(paste("A",1: nbAlleles,sep=""),paste("A",1: nbAlleles,sep=""),paste("L",1:nbLoci,sep=""))) # Initialising a matrix that will contain the genotypic effects on the/a trait
for(L in 1:nbLoci)
{
# Setting the effects for the homozygotes [all loci]
effect<-abs(rnorm(n=1,mean=0,sd=SDZ))# alter the locus importance in a realistic way (many small-effect loci, few major loci)
diag(gvaluesZ[,,L])<-2*rnorm(n=dim(gvaluesZ)[1],mean=0,sd=effect)
# Setting the effects for the heterozygotes
for(A in 1:(nbAlleles-1))# loop for off-diagonal = heterozygotes (additive and dominance effects)
{
for (D in (A+1):nbAlleles)
{
d<-dominance*runif(n=1,min=-0.5-overdominance,max=0.5+overdominance)
gvaluesZ[A,D,L]<-(0.5-d)*gvaluesZ[A,A,L]+(0.5+d)*gvaluesZ[D,D,L] # mean of additive effects + dominance, over diagonal
gvaluesZ[D,A,L]<-(0.5-d)*gvaluesZ[A,A,L]+(0.5+d)*gvaluesZ[D,D,L] # the same below diagonal
}
}
}
############### Genetic determinism H
dominance<-1 # for additive effects only, must be 0
overdominance<-0 # non-null values generate overdominance
nbLoci<-10 #number of loci controling the trait phenotype
nbAlleles<-10 #number of existing alleles per loci
gvaluesH<-array(data=NA,dim=c(nbAlleles,nbAlleles,nbLoci),dimnames=list(paste("A",1: nbAlleles,sep=""),paste("A",1: nbAlleles,sep=""),paste("L",1:nbLoci,sep=""))) # Initialising a matrix that will contain the genotypic effects on the/a trait
for(L in 1:nbLoci)
{
# Setting the effects for the homozygotes [all loci]
effect<-abs(rnorm(n=1,mean=0,sd=SDH))# alter the locus importance in a realistic way (many small-effect loci, few major loci)
diag(gvaluesH[,,L])<-2*rnorm(n=dim(gvaluesH)[1],mean=0,sd=effect)
# Setting the effects for the heterozygotes
for(A in 1:(nbAlleles-1))# loop for off-diagonal = heterozygotes (additive and dominance effects)
{
for (D in (A+1):nbAlleles)
{
d<-dominance*runif(n=1,min=-0.5-overdominance,max=0.5+overdominance)
gvaluesH[A,D,L]<-(0.5-d)*gvaluesH[A,A,L]+(0.5+d)*gvaluesH[D,D,L] # mean of additive effects + dominance, over diagonal
gvaluesH[D,A,L]<-(0.5-d)*gvaluesH[A,A,L]+(0.5+d)*gvaluesH[D,D,L] # the same below diagonal
}
}
}
############### Definition of the class ############
setClass(
Class="Leprechaun",
representation=representation(
ID = "integer",
pID = "integer",
age = "integer",
Birth = "integer",
alive = "logical",
size = "numeric",
hunting = "numeric",
camemberts = "integer",
sex = "character",
DNAZ = "matrix",
DNAH = "matrix",
bvs = "numeric",
bvh = "numeric",
ARS = "integer"
)
)
############### Definition of the basic methods (for printing to the screen and initialisation)
setMethod("show","Leprechaun",
function(object){
cat(object@ID,"\t",object@size,"\t",object@camemberts,"\t",object@age,"\t",object@sex,"\t(",object@pID[1],",",object@pID[2],")\t",object@Birth,"\t",object@alive,"\n",sep="")
}
)
setMethod("initialize","Leprechaun",function(.Object,parent1,parent2){
.Object@DNAZ<-matrix(NA,nrow=2,ncol=nbLoci)
.Object@DNAH<-matrix(NA,nrow=2,ncol=nbLoci)
if(missing(parent1)){
parent1<-NA
.Object@DNAZ[1,]<-floor(runif(nbLoci,min=1,max=nbAlleles+1))
.Object@DNAH[1,]<-floor(runif(nbLoci,min=1,max=nbAlleles+1))
}else{
#weight1<-pop[[parent1]]@size
.Object@DNAZ[1,]<-pop[[parent1]]@DNAZ[cbind(floor(runif(n=nbLoci,min=1,max=3)),1:nbLoci)]
.Object@DNAH[1,]<-pop[[parent1]]@DNAH[cbind(floor(runif(n=nbLoci,min=1,max=3)),1:nbLoci)]
}
if(missing(parent2)){
parent2<-NA
.Object@DNAZ[2,]<-floor(runif(nbLoci,min=1,max=nbAlleles+1))
.Object@DNAH[2,]<-floor(runif(nbLoci,min=1,max=nbAlleles+1))
}else{
.Object@DNAZ[2,]<-pop[[parent2]]@DNAZ[cbind(floor(runif(n=nbLoci,min=1,max=3)),1:nbLoci)]
.Object@DNAH[2,]<-pop[[parent2]]@DNAH[cbind(floor(runif(n=nbLoci,min=1,max=3)),1:nbLoci)]
}
.Object@age<-as.integer(0)
.Object@ID<-CID
.Object@pID<-c(as.integer(parent1),as.integer(parent2))
.Object@Birth<-as.integer(YR)
.Object@alive<-TRUE
BreedingValueSize<-0
for (Locus in 1:nbLoci)#take the mean of genetic values
{
BreedingValueSize<-BreedingValueSize+(gvaluesZ[ .Object@DNAZ[1,Locus], .Object@DNAZ[2,Locus], Locus]/nbLoci)
}
.Object@bvs<-BreedingValueSize
size<-MeanBirthSize+BreedingValueSize
.Object@size<-rnorm(n=1,mean=size,sd=0) # sd plasticity birth size
BreedingValueHunting<-0
for (Locus in 1:nbLoci)#take the mean of genetic values
{
BreedingValueHunting<-BreedingValueHunting+(gvaluesH[ .Object@DNAH[1,Locus], .Object@DNAH[2,Locus], Locus]/nbLoci)
}
.Object@bvh<-BreedingValueHunting
.Object@hunting<-rnorm(n=1,mean=.Object@bvh,sd=0.5) # sd plasticity hunting quality
.Object@camemberts<-as.integer(0)
.Object@ARS<-as.integer(0)#annual reproductive success
if(runif(1)>0.5){.Object@sex<-'F'}else{.Object@sex<-'M'}
CID<<-as.integer(CID+1)
return(.Object)
})
source('~/GitHub/CarpentryExercise/S4imulations.R', echo=TRUE)
source('~/GitHub/CarpentryExercise/S4imulations.R', echo=TRUE)
source('C:/Users/Timothée/Documents/GitHub/CarpentryExercise/S4imulations.R')
source('~/GitHub/CarpentryExercise/S4imulations.R', echo=TRUE)
source('C:/Users/Timothée/Documents/GitHub/CarpentryExercise/S4imulations.R')
pop<-c(new("Leprechaun"))
pop
pop<-replicate(n = 10,expr = new("Leprechaun"))
pop
for(YR in 1:30){
camembert<-abs(round(rnorm(n=1,mean=MeanCamembert,sd=SDCamembert),digits=0)) # resources for year YR
print_info(YR,ALIVE,CID,camembert)
#### Competition for resources
HuntingAlive<-as.numeric(lapply(pop[ALIVE],Hunting))
HunterQualities<- abs(HuntingAlive - mean(HuntingAlive)) # here the most original individuals have a strong advantage in the competition (f-dpd selection)
if(sum(HunterQualities)==0){HunterQualities=rep(x=1,length(HunterQualities))}
podium<-table(factor(sample(as.character(ALIVE),size=camembert,replace=T,prob=HunterQualities),levels=ALIVE))
camams<-as.numeric(podium[match(ALIVE,names(podium))])
pop[ALIVE]<-lapply(1:length(ALIVE), function(x) Food(pop[[ALIVE[x]]],camams[x]))
#### Survival
DEAD<-c()
pop[ALIVE]<-lapply(pop[ALIVE],Surv)
ALIVE<-ALIVE[!(ALIVE %in% DEAD)]
if(length(ALIVE)==0){
for(i in DEAD){
cat("\n",YR,"\t",pop[[i]]@ID,"\t",pop[[i]]@size,"\t",pop[[i]]@bvs,"\t",pop[[i]]@hunting,"\t",pop[[i]]@bvh,"\t",pop[[i]]@camemberts,"\t",pop[[i]]@sex,"\t",pop[[i]]@ARS,"\t",pop[[i]]@age,"\t",pop[[i]]@pID[1],"\t",pop[[i]]@pID[2],"\t",0,file=filename,append=TRUE)
}
break
}
#### Age+1 and growth
pop[ALIVE]<-lapply(pop[ALIVE],Age)
pop[ALIVE]<-lapply(pop[ALIVE],Grow)
#### Reproduction
##########
### Part dedicated to retrieving the indices of all living males and of all living females
##########
males<-lapply(pop,Sex)=="M" # Determine which individuals are males -- logicaly all other individuals should be females... However, this includes dead ones... Simply a list of T,T,F,F,T,F,F,....
females<-which(!males) # Get the indices of the non-males (that is females..)
males<-which(males)   # Get the indices of the males
females<-intersect(females,ALIVE) # Retrieve the indices of the living(!) females
males <-intersect(males,ALIVE) # Retrieve the indises of the living males
#cat(females)
##########
# Part dedicated to breeding..
##########
# We take a female based approach: we determine for each females
from<-CID
pop[females]<-lapply(pop[females],Num_off)
for(i in females){
Noffs<-pop[[i]]@ARS
if(Noffs>0 & length(males>0)){
#Determine the father
fat<-sample(males,1)
for(j in 1:Noffs){
#cat(j,"\n")
# Create the offspring
pop<-c(pop,new("Leprechaun",parent1=i,parent2=fat))
}
}
}
if(from!=CID){
ALIVE<-c(ALIVE,(from):(CID-1))
}
### Everything should be written to a dataframe, to make sure we have all the values for ever and ever
for(i in ALIVE){
cat("\n",YR,"\t",pop[[i]]@ID,"\t",pop[[i]]@size,"\t",pop[[i]]@bvs,"\t",pop[[i]]@hunting,"\t",pop[[i]]@bvh,"\t",pop[[i]]@camemberts,"\t",pop[[i]]@sex,"\t",pop[[i]]@ARS,"\t",pop[[i]]@age,"\t",pop[[i]]@pID[1],"\t",pop[[i]]@pID[2],"\t",1,file=filename,append=TRUE)
}
for(i in DEAD){
cat("\n",YR,"\t",pop[[i]]@ID,"\t",pop[[i]]@size,"\t",pop[[i]]@bvs,"\t",pop[[i]]@hunting,"\t",pop[[i]]@bvh,"\t",pop[[i]]@camemberts,"\t",pop[[i]]@sex,"\t",pop[[i]]@ARS,"\t",pop[[i]]@age,"\t",pop[[i]]@pID[1],"\t",pop[[i]]@pID[2],"\t",0,file=filename,append=TRUE)
}
}
MeanCamembert<-200
source('~/GitHub/CarpentryExercise/Application.R', echo=TRUE)
file(filename, "r", encoding = encoding)
filename<-'~/GitHub/CarpentryExercise/Application.R'
file(filename, "r", encoding = encoding)
encoding<-NA
file(filename, "r", encoding = encoding)
encoding<-"UTF-8"
file(filename, "r", encoding = encoding)
encoding<-""
file(filename, "r", encoding = encoding)
getOption(x, default = NULL)
getOption()
getOption(encoding)
getOption("encoding")
source('C:/Users/Timothée/Documents/GitHub/CarpentryExercise/Application.R')
SDCamembert<-10
source('C:/Users/Timothée/Documents/GitHub/CarpentryExercise/Application.R')
source('C:/Users/Timothée/Documents/GitHub/CarpentryExercise/S4imulations.R')
source('C:/Users/Timothée/Documents/GitHub/CarpentryExercise/S4imulations.R')
